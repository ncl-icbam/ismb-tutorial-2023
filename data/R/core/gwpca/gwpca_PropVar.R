#' @name prop.var
#'
#' @param n_components Numeric vector specifying the number of principal 
#' components.
#' @param gwpca_var Matrix containing the variance values from a gwpca object.
#'
#' @return Numeric vector representing the proportion of variance explained by 
#' the specified number of principal components.
#' 
#' @description
#' The `prop.var` function calculates the proportion of variance explained by 
#' the specified number of principal components. It takes a numeric vector 
#' `n_components` indicating the number of principal components for which the 
#' variance is calculated. The variance values are obtained from the `gwpca_var`
#' matrix, which is typically the `$var` slot of a gwpca object. The resulting 
#' proportion of variance explained is expressed as a percentage.
#'
#'
#' @seealso
#' Other functions related to principal component analysis: `gwpca`, `pca`, 
#' `prcomp`, `princomp`
prop.var <- function(n_components, gwpca_var) {
    if (any(n_components <= 1) || any(n_components > ncol(gwpca_var))) {
        cat("n_components must be a numeric vector with values > 1 and less 
            than ncol(gwpca$var).")
        stop()
    }
    if (!is.matrix(gwpca_var)) {
        stop("gwpca_var must be a matrix.")
    }
    
    rowSums(gwpca_var[, 1:n_components]) / rowSums(gwpca_var) * 100
}
# ---------------------------------------------------------------------------- #
#' Calculate Proportional Variance Explained by Principal Components
#' 
#' Calculates the proportional variance explained by the specified number of 
#' principal components in a gwpca object's variance matrix. The function 
#' returns a data frame with the proportional variance for each component on 
#' each location and the corresponding spot geometries.
#' 
#' @name gwpca_propVar
#' 
#' @param gwpca A \code{gwpca} class object containing the result of the 
#' Geographically Weighted Principal Component Analysis. As generated by 
#' \code{gwpca.ste}
#' @param n_comp A numeric vector specifying the number of principal components 
#' for which to calculate the proportional variance.
#' @param sfe A \code{SpatialFeatureExperiment} (SFE) object used to extract the
#' spot geometries.
#'
#' @return A data frame with columns for the proportional variance explained by 
#' each principal component and the corresponding spot geometries from SFE's
#' `spotHex`.
#'
#' @export
#'
#' @examples
#' # Assuming gwpca_obj is a gwpca object and sfe_obj is an SFE object:
#' result <- gwpca.prop.var(gwpca_obj, n_comp = 2:10, sfe = sfe_obj)
#' print(result)
#'
gwpca_PropVar <- function(gwpca, n_comp, sfe){
    ## Check valid input arguments
    if (!inherits(gwpca, "gwpca")) {
        stop("gwpca must be a valid `gwpca` class object.")
    }
    if (!is.numeric(n_comp) || any(n_comp <= 1) || any(n_comp > 
                                                       ncol(gwpca$var))) {
        cat("n_comp must be a numeric vector with values between 2 and the 
            number of components in gwpca$var.")
        stop()
    }
    if (!inherits(sfe, "SpatialFeatureExperiment")) {
        stop("sfe must be a SpatialFeatureExperiment object.")
    }
    
    ## apply prop.var() over the n.comp vector
    ptvs_list <- lapply(n_comp, prop.var, gwpca_var = gwpca$var)
    ptvs_list <- rlist::list.prepend(ptvs_list, 
                                     gwpca$var[,1]/rowSums(gwpca$var) * 100)
    
    ## set names to the list objects
    ptvs_list <- setNames(ptvs_list, sprintf("Comps_%02d", c(1, n_comp)))
    
    ## Combine into one data frame
    ptvs <- bind_rows(ptvs_list, .id = "column_labels")
    
    ## Print summary outside the function
    ptvs_summary <- summary(ptvs)
    print(ptvs_summary)
    
    ## Add spotHex geometries
    gwpca$ptvs <- dplyr::mutate(ptvs, 
                                geometry = colGeometry(sfe, "spotHex")$geometry)
    
    
    return(gwpca)
}

