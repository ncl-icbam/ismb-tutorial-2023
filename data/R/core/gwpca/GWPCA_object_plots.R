## GUIDE ----
## A script for plots for the GWPCA results.
# Ignore test data#
# gwpca <- pcagw_stex
# comps <- 1:2
# pc.nos <- 1:3
# pc_no <- 1
# rm(gwpca, pvar, plot_types, comps, df, scores, pc.no, .gwpca,
# .pc.nos, .genes.n, .sfe, .method, coerced_list, df,dt,dt_top,dt_top_IDs,
# dt_top_gn,gwpca.scores,lead.item,local.loadings,p,results2,results, scores,
# temp,temp_IDs,col.No,match_indices,pc.name,temp_gn,unique.n)
#-----------------#

## 1. Global PCA: scree/ scatter plots ----
#' @name plotGWPCA_global
#' @description
#' A function to plot the global PCA results as generated by \code{gwpca.ste}.
#' Has to options, 'scree' and 'scatter'. The first will plot a scree plot of 
#' the percentage of total variation of a selection of principal components. The
#' latter will produce a scatter plot of the two selected components.
#' 
#' @param gwpca a list of class \code{gwpca}, generated by \code{gwpca.ste}.
#' @param comps the components to be plotted. If type == scree, it is a numeric
#' vector. If type == scatter, it is a numeric vector of length 2 
#' (i.e., comps 1:2 will plot the two first components).
#' @param type either 'scree' or 'scatter'.
#' @param point_args arguments to pass to \code{geom_point()} when you don't 
#' want them to be shared with \code{geom_line()}.
#' @param line_args arguments to pass to \code{geom_line()} when you don't 
#' want them to be shared with \code{geom_point()}.
#' @param ... arguments to be passed to both \code{geom_point()} and 
#' \code{geom_line()}.
#' 
#' @return A ggplot object.
#' 
#' @export

plotGWPCA_global <- function(gwpca, 
                             comps = 1:10, 
                             type = c("scree", "scatter"),
                             point_args = list(),
                             line_args = list(),
                             ...) {
  ## Checks arguments
  stopifnot(is(gwpca, "gwpca"))
  stopifnot(is.numeric(comps))
  stopifnot(is.list(point_args))
  stopifnot(is.list(line_args))

  ## Check valid type argument
  type <- match.arg(type)

  ## Prepare data
  if (type == "scree") {
    ## Calculate percent of variation explained
    pvar <- (gwpca$pca$sdev^2/sum(gwpca$pca$sdev^2))*100
    pvar <- data.frame(var = pvar,
                       PCs = sprintf("PC%03d", seq_along(pvar)))
  } else if (type == "scatter") {
    ## Extract scores for two components
    scores <- gwpca$pca$scores[, comps]
    df <- data.frame(scores[, comps[1]], scores[, comps[2]])
    colnames(df) <- sprintf("PC%d", seq_along(pvar))
  }
  
  ## Plot types for global PCA results
  plot_types <- list(
    scree = function(point_args, line_args, ...) {
      ggplot(pvar[comps,], aes(x = PCs, y = var, group = 1)) +
        do.call(geom_line, c(list(...), line_args)) +
        do.call(geom_point, c(list(...), point_args)) +
        xlab("Principal Component") +
        ylab("% Variance Explained") +
        ggtitle("Scree Plot") +
        ylim(0, 100) + 
        theme_classic()
    },
    scatter = function(point_args, ...) {
      ggplot(df, aes(x = df[,1], y = df[,2])) +
        do.call(geom_point, c(list(...), point_args)) +
        xlab(paste0("Principal Component ", comps[1])) +
        ylab(paste0("Principal Component ", comps[2])) +
        ggtitle(paste0("PCA Plot of ", colnames(df)[1], 
                       " vs ", colnames(df)[2])) + 
        theme_classic()
    }
  )
  
  ## Plot
  plot_fun <- plot_types[[type]]
  
  if (is.null(plot_fun)) {
    stop("Invalid type argument. Valid options are 'scree' and 'scatter'.")
  }
  
  ## Call plot function with arguments
  plot <- do.call(plot_fun, 
                  c(list(point_args = point_args, line_args = line_args), ...))
  
  ## Return plot
  return(plot)
}

# 2. Leading genes: maps ----
#' @name plotGWPCA_leadingG
#' @description
#' A function to map the leading genes or leading gene groups per location.
#' 
#' @param gwpca a list of class \code{gwpca}, generated by \code{gwpca.ste} and
#' updated with leading genes by \code{gwpca.LeadingGene}.
#' @param comps the components to be plotted. If type == scree, it is a numeric
#' vector. If type == scatter, it is a numeric vector of length 2 
#' (i.e., comps 1:2 will plot the two first components).
#' @param type either 'single' for single leading gene per location or 'multi'
#' for k leading genes per location.
#' @param arrange to indicate whether to arrange the plots in a panel or not. 
#' The default is set to FALSE.
#' @param ... arguments to be passed to both \code{geom_sf()} outside of the 
#' aesthetic.
#' 
#' @return Returns a list of plots; one per Principal Component. If arrange == 
#' TRUE then a 2x2 panel is plotted too. If more than 4 PCs are provided in the 
#' \code{comps} argument then only a list of plots is returned.
#' 
#' @export

plotGWPCA_leadingG <- function(gwpca,
                               comps,
                               type = c("single", "multi"),
                               arrange = FALSE,
                               ...){
  ## Checks arguments
  stopifnot(is(gwpca, "gwpca"))
  stopifnot(is.numeric(comps))
  
  ## Check valid type argument
  type <- match.arg(type)
  
  ## Fetch the data
  if (type == "single") {
    lead.item <- gwpca$leadingGeneSingle
    legend <- "right"
    title <- "Genes"
  } else if (type == "multi") {
    lead.item <- gwpca$leadingGeneMulti
    legend <- "none"
    title <- "Genes Groups"
  }
  
  ## Define a function to generate the plot for a given component
  generate_plot <- function(pc.No) {
    col.No <- length(unique(lead.item[, pc.No]))
    colour.values <- get.colours(col.No)
    
    ggplot() + 
      geom_sf(aes(geometry = lead.item$geometry$geometry, 
                  fill = lead.item[, pc.No]), ...) +
      scale_fill_manual(values = colour.values) + 
      labs(title = paste0("Leading ", title, " on PC", pc.No),
           fill = "Leading Genes") +
      theme_void() + 
      theme(legend.position = legend)
  }
  
  ## Create a list of plots for each component using lapply
  plots <- lapply(comps, generate_plot)
  
  ## Check if arrange is TRUE and comps length is less than or equal to 4
  if (arrange && length(comps) <= 4) {
    n <- length(comps)
    nrow <- if (n %in% c(1, 2)) 1 else 2
    ncol <- if (n == 3) 2 else 2
    do.call(gridExtra::grid.arrange, c(plots, nrow = nrow, ncol = ncol))
    message("Plots arranged in a ", nrow, "x", ncol, " panel.")
  } else if (length(comps) > 4) {
    message("More than 4 components specified. 
    Returning a list of individual plots.")
  }
  
  ## Return the list of plots
  return(plots)
}


# 3. Leading genes: maps ----