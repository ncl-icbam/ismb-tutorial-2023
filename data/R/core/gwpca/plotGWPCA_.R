## GUIDE ----
## A script for plots for the GWPCA results.
# Ignore test data#
# gwpca <- pcagw_stex
# comps <- 1:2
# pc.nos <- 1:3
# pc_no <- 1
# rm(gwpca, pvar, plot_types, comps, df, scores, pc.no, .gwpca,
# .pc.nos, .genes.n, .sfe, .method, coerced_list, df,dt,dt_top,dt_top_IDs,
# dt_top_gn,gwpca.scores,lead.item,local.loadings,p,results2,results, scores,
# temp,temp_IDs,col.No,match_indices,pc.name,temp_gn,unique.n)
#-----------------#

## 1. Global PCA: scree/ scatter plots ----
#' @name plotGWPCA_global
#' @description
#' A function to plot the global PCA results as generated by \code{gwpca.ste}.
#' Has to options, 'scree' and 'scatter'. The first will plot a scree plot of 
#' the percentage of total variation of a selection of principal components. The
#' latter will produce a scatter plot of the two selected components.
#' 
#' @param gwpca a list of class \code{gwpca}, generated by \code{gwpca.ste}.
#' @param comps the components to be plotted. If type == scree, it is a numeric
#' vector. If type == scatter, it is a numeric vector of length 2 
#' (i.e., comps 1:2 will plot the two first components).
#' @param type either 'scree' or 'scatter'.
#' @param point_args arguments to pass to \code{geom_point()} when you don't 
#' want them to be shared with \code{geom_line()}.
#' @param line_args arguments to pass to \code{geom_line()} when you don't 
#' want them to be shared with \code{geom_point()}.
#' @param ... arguments to be passed to both \code{geom_point()} and 
#' \code{geom_line()}.
#' 
#' @return A ggplot object.
#' 
#' @export

plotGWPCA_global <- function(gwpca, 
                             comps = 1:10, 
                             type = c("scree", "scatter"),
                             point_args = list(),
                             line_args = list(),
                             ...) {
    ## Checks arguments
    stopifnot(is(gwpca, "gwpca"))
    stopifnot(is.numeric(comps))
    stopifnot(is.list(point_args))
    stopifnot(is.list(line_args))
    
    ## Check valid type argument
    type <- match.arg(type)
    
    ## Prepare data
    if (type == "scree") {
        ## Calculate percent of variation explained
        pvar <- (gwpca$pca$sdev^2/sum(gwpca$pca$sdev^2))*100
        pvar <- data.frame(var = pvar,
                           PCs = sprintf("PC%03d", seq_along(pvar)))
    } else if (type == "scatter") {
        ## Extract scores for two components
        scores <- gwpca$pca$scores[, comps]
        if (is.null(scores)) {
            cat("To be able to plot a scatter plot of PCs you need to run the",
                "`gwpcaSTE` function with the `scores` argument set to TRUE.\n")
            stop()
        }
        df <- data.frame(scores[, comps[1]], scores[, comps[2]])
        colnames(df) <- sprintf("PC%d", seq_along(colnames(scores)))
    }
    
    ## Plot types for global PCA results
    plot_types <- list(
        scree = function(point_args, line_args, ...) {
            ggplot(pvar[comps,], aes(x = PCs, y = var, group = 1)) +
                do.call(geom_line, c(list(...), line_args)) +
                do.call(geom_point, c(list(...), point_args)) +
                xlab("Principal Component") +
                ylab("% Variance Explained") +
                ggtitle("Scree Plot") +
                ylim(0, 100) + 
                theme_classic()
        },
        scatter = function(point_args, ...) {
            ggplot(df, aes(x = df[,1], y = df[,2])) +
                do.call(geom_point, c(list(...), point_args)) +
                xlab(paste0("Principal Component ", comps[1])) +
                ylab(paste0("Principal Component ", comps[2])) +
                ggtitle(paste0("PCA Plot of ", colnames(df)[1], 
                               " vs ", colnames(df)[2])) + 
                theme_classic()
        }
    )
    
    ## Plot
    plot_fun <- plot_types[[type]]
    
    if (is.null(plot_fun)) {
        stop("Invalid type argument. Valid options are 'scree' and 'scatter'.")
    }
    
    ## Call plot function with arguments
    plot <- do.call(plot_fun, 
                    c(list(point_args = point_args, line_args = line_args), ...))
    
    ## Return plot
    return(plot)
}

# 2. Leading genes: maps ----
#' @name plotGWPCA_leadingG
#' @description
#' A function to map the leading genes or leading gene groups per location.
#' 
#' @param gwpca a list of class \code{gwpca}, generated by \code{gwpca.ste} and
#' updated with leading genes by \code{gwpca.LeadingGene}.
#' @param comps the components to be plotted.
#' @param type either 'single' for single leading gene per location or 'multi'
#' for k leading genes per location.
#' @param arrange to indicate whether to arrange the plots in a panel or not. 
#' The default is set to FALSE.
#' @param ... arguments to be passed to both \code{geom_sf()} outside of the 
#' aesthetic.
#' 
#' @return Returns a list of plots; one per Principal Component. If arrange == 
#' TRUE then a 2x2 panel is plotted too. If more than 4 PCs are provided in the 
#' \code{comps} argument then only a list of plots is returned.
#' 
#' @export

plotGWPCA_leadingG <- function(gwpca,
                               comps,
                               type = c("single", "multi"),
                               arrange = FALSE,
                               ...){
    ## Checks arguments
    stopifnot(is(gwpca, "gwpca"))
    stopifnot(is.numeric(comps))
    
    ## Check valid type argument
    type <- match.arg(type)
    
    ## Fetch the data
    if (type == "single") {
        lead.item <- gwpca$leadingGeneSingle
        legend <- "right"
        title <- "Genes"
    } else if (type == "multi") {
        lead.item <- gwpca$leadingGeneMulti
        legend <- "none"
        title <- "Genes Groups"
    }
    
    ## Define a function to generate the plot for a given component
    generate_plot <- function(pc.No) {
        col.No <- length(unique(lead.item[, pc.No]))
        colour.values <- get.colours(col.No)
        
        ggplot() + 
            geom_sf(aes(geometry = lead.item$geometry$geometry, 
                        fill = lead.item[, pc.No]), ...) +
            scale_fill_manual(values = colour.values) + 
            labs(title = paste0("Leading ", title, " on PC", pc.No),
                 fill = "Leading Genes") +
            theme_void() + 
            theme(legend.position = legend)
    }
    
    ## Create a list of plots for each component using lapply
    plots <- lapply(comps, generate_plot)
    
    ## Check if arrange is TRUE and comps length is less than or equal to 4
    if (arrange && length(comps) <= 4) {
        n <- length(comps)
        nrow <- if (n %in% c(1, 2)) 1 else 2
        ncol <- if (n == 3) 2 else 2
        do.call(gridExtra::grid.arrange, c(plots, nrow = nrow, ncol = ncol))
        message("Plots arranged in a ", nrow, "x", ncol, " panel.")
    } else if (length(comps) > 4) {
        message("More than 4 components specified. 
    Returning a list of individual plots.")
    }
    
    ## Return the list of plots
    return(plots)
}


# 3. Percent of Total Variation: violin/ map ----
#' @name plotGWPCA_ptv
#' @description
#' A function to plot and map the Percent of Total Variation (PTV) of the local 
#' Principal Components for each location.
#' 
#' @param gwpca a list of class \code{gwpca}, generated by \code{gwpca.ste} and
#' updated with leading genes by \code{gwpca.LeadingGene}.
#' @param comps the components to be plotted. The maximum is based on the max 
#' number of components used in the \code{gwpca.propVar} function. If one 
#' component is provided here, then only one violin plot or map will be plotted.
#' If it is a numeric vector then the corresponding plots will be plotted.
#' @param type either 'single' for single leading gene per location or 'multi'
#' for k leading genes per location.
#' @param violin_args a list of arguments to be passed to \code{geom_violin()}
#' for customizing the violin plots. Defaults to an empty list.
#' @param box_args a list of arguments to be passed to \code{geom_boxplot()} for
#' customizing the boxplots. Defaults to an empty list.
#' @param fill_args a list of arguments to be passed to 
#' \code{scale_fill_manual()} for customizing the fill colors of the plots. 
#' Defaults to an empty list.
#' @param lab_args a list of arguments to be passed to \code{labs()} for 
#' customizing the plot labels. Defaults to an empty list.
#' @param ... arguments to be passed to both \code{geom_sf()} outside of the 
#' aesthetic.
#' 
#' @details
#' The comps argument is passed down to select the aggregates of components to 
#' be plotted. Remember that PTVs are cumulative. This means that Comps_01 
#' inside \code{gwpca$ptvs} shows the PTV for PC 1 per location. Next, Comps_02
#' shows the cumulative PTV for PCs 1 and 2 per location etc. As a result, when 
#' you give `comps` = c(1, 5) then the violin plots for the cumulative PTV of 
#' the first and the first 5 PCs per location will be plotted or mapped. If you
#' provide a single number then a single violin plot or map will be plotted. If
#' you provide a vector of numbers then a plot with multiple violins (arrange = 
#' TRUE), or multiple single violins, or a panel of maps will be plotted, or
#' multiple single maps.
#' 
#' @return Returns a ggplot object.
#' 
#' @export
plotGWPCA_ptv <- function(gwpca,
                          comps,
                          type = c("violin", "map"),
                          violin_args = list(),
                          box_args = list(),
                          fill_args = list(),
                          lab_args = list(),
                          ...){
    ## Checks arguments
    stopifnot(is(gwpca, "gwpca"))
    stopifnot(is.numeric(comps))
    stopifnot(!is.null(gwpca$ptvs))
    
    ## Check valid type argument
    type <- match.arg(type)
    
    ## Fetch the data
    if (type == "violin") {
        ptvs <- gwpca$ptvs[,!(colnames(gwpca$ptvs) %in% "geometry")] %>%
            .[, comps] %>% 
            reshape2::melt(data = ., measure.vars = colnames(.))
    } else if (type == "map") {
        col_ns <- colnames(gwpca$ptvs)[comps]
        ptvs <- gwpca$ptvs %>% 
            select(all_of(c(col_ns, "geometry"))) %>% 
            reshape2::melt(data = ., measure.vars = col_ns)
    }
    
    ## Set some defaults if not provided
    if (isEmpty(violin_args) & type == "violin") {
        violin_args <- list(alpha = 0.8,
                            trim = FALSE)
    }
    if (isEmpty(box_args) & type == "violin") {
        box_args <- list(width = 0.1, 
                         fill = "grey40", 
                         outlier.colour = NA)
    }
    if (isEmpty(fill_args)) {
        fill_args <- list(values = get.colours(length(comps)))
    }
    if (isEmpty(lab_args) & type == "violin") {
        labs_args <- list(title = "Local PCs PTV",
                          x = "",
                          y = "Percentage of Total Variation (PTV)",
                          fill = "No. of PCs")
    } else if (isEmpty(lab_args) & type == "map") {
        labs_args <- list(title = "Percantage of Total Variation\n(PTV)")
    }
    
    ## Set some defaults if not priovided
    if (isEmpty(violin_args) & type == "violin") {
        violin_args <- list(alpha = 0.8,
                            trim = FALSE)
    }
    if (isEmpty(box_args) & type == "violin") {
        box_args <- list(width = 0.1, 
                         fill = "grey40", 
                         outlier.colour = NA)
    }
    if (isEmpty(fill_args)) {
        fill_args <- list(values = get.colours(length(comps)))
    }
    if (isEmpty(lab_args) & type == "violin") {
        labs_args <- list(title = "Local PCs PTV",
                          x = "",
                          y = "Percentage of Total Variation (PTV)",
                          fill = "No. of PCs")
    } else if (isEmpty(lab_args) & type == "map") {
        labs_args <- list(title = "Percantage of Total Variation\n(PTV)")
    }
    
    ## List of plots
    plot_list <- list(
        violin = function(violin_args, box_args, labs_args, fill_args, ...){
            ggplot(ptvs, aes(x = variable, y = value, fill = variable)) + 
                do.call(geom_violin, c(list(...), violin_args)) +
                do.call(scale_fill_manual, c(fill_args)) +
                do.call(geom_boxplot, c(list(...), box_args)) +
                do.call(labs, labs_args) +
                ylim(0, 100) +
                theme_classic()
        },
        map = function(comps, labs_args, ...){
            ggplot(data = ptvs) + 
                geom_sf(aes(geometry = geometry, fill = value), ...) +
                scale_fill_viridis_c(option = "magma", limits = c(0, 100)) +
                facet_wrap(~variable, ncol = ceiling(sqrt(n_distinct(comps)))) +
                do.call(labs, labs_args) +
                theme_void() + 
                theme(legend.position = "right")
        }
    )
    
    ## Get the required plot function
    plot_fun <- plot_list[[type]]
    
    ## Fetch appropriate arguments
    if (type == "violin") {
        args_list <- list(violin_args = violin_args, 
                          box_args = box_args, 
                          labs_args = labs_args,
                          fill_args = fill_args)
    } else if (type == "map") {
        args_list <- list(comps = comps,
                          labs_args = labs_args)
    }
    
    ## Call plot function with appropriate arguments
    plot <- do.call(plot_fun, 
                    c(list(...), args_list))
    
    return(plot)
}

# 4. Plot discrepancies: boxplot/ map ----
#' @name plotGWPCA_discr
#' @description
#' A short description...
#' 
#' @param 
#' 
#' @details
#' Additional details...
#' 
#' @return description
#' 
#' @example path.R
#' 
#' @export
#' 
#' 
#' @name plotGWPCA_discr
#' 
#' 
#' @description
#' This function plots discrepancies using either a boxplot or a map. It 
#' visualizes the discrepancies in the local Principal Components (PCs) for each
#' location based on the coefficient of variation (CV).
#' 
#' @param gwpca A list of class `gwpca` containing the necessary data.
#' @param type Specifies the type of plot to generate. Can be either "box" for 
#' a boxplot or "map" for a map. Default is "box".
#' @param box_args Additional arguments to customize the appearance of the 
#' boxplot.
#' @param jitt_args Additional arguments to customize the appearance of the 
#' jitter points in the boxplot.
#' @param hline_args Additional arguments to customize the appearance of the 
#' horizontal line in the boxplot.
#' @param lab_args Additional arguments to customize the labels of the plot.
#' @param ... Additional arguments to be passed to the `geom_boxplot()` or 
#' `geom_sf()` functions.
#' 
#' @details
#' # Dependencies
#' The function depends on the `ggplot2` and `sf` packages.
#' 
#' The function first checks the validity of the input arguments. It then 
#' fetches the necessary data from the `gwpca` object and calculates the 
#' outliers using the `outlier_cutoff()` function. Depending on the `type` 
#' specified, the data is prepared accordingly for either a boxplot or a map.
#' 
#' For the boxplot, the discrepancies (`cvs`) are reshaped into a data frame and
#' plotted using `geom_boxplot()`. Jitter points can also be added using 
#' `geom_jitter()`. A horizontal line is drawn at the upper outlier threshold. 
#' Customization of the plot appearance is possible through the provided 
#' arguments.
#' 
#' For the map, the discrepancies, along with the geometry information, are 
#' combined into a data frame. The map is then created using `geom_sf()`, with 
#' the discrepancies represented by fill color. Outliers are also marked with a 
#' transparent fill color and a black border. Customization options for the map 
#' appearance are available through the arguments.
#' 
#' @return The function returns the created plot.
#' 
#' @example
#' 
#' # Load required packages
#' library(ggplot2)
#' library(sf)
#' 
#' # Generate example data
#' data <- data.frame(
#'   cvs = rnorm(100, mean = 0, sd = 1),
#'   geometry = st_sfc(st_point(x = runif(100), y = runif(100)))
#' )
#' gwpca <- list(CV = data$cvs, geometry = data$geometry)
#' 
#' # Plot discrepancies as a boxplot
#' plotGWPCA_discr(gwpca, type = "box")
#' 
#' # Plot discrepancies as a map
#' plotGWPCA_discr(gwpca, type = "map")
#' @depe
#' @export



plotGWPCA_discr <- function(gwpca,
                            type = c("box", "map"),
                            box_args = list(),
                            jitt_args = list(),
                            hline_args = list(),
                            lab_args = list(),
                            ...){
    ## Checks arguments
    stopifnot(is(gwpca, "gwpca"))
    stopifnot(!is.null(gwpca$geometry))
    stopifnot(!is.null(gwpca$CV))
    
    ## Check valid type argument
    type <- match.arg(type)
    
    ## Fetch the data
    if (type == "box") {
        discs <- data.frame(cvs = gwpca$CV$CV) %>% 
            reshape2::melt(data = ., measure.vars = colnames(.))
    } else if (type == "map") {
        discs <- data.frame(cvs = gwpca$CV$CV, 
                            is_disc = gwpca$CV$is_outlier,
                            geometry = gwpca$geometry) %>% 
            mutate(out_geom = geometry,
                   out_geom = if_else(is_disc == FALSE, NA, out_geom))
    }
    
    ## Set some defaults if not provided
    if (isEmpty(box_args) & type == "box") {
        box_args <- list(width = 0.8,
                         fill = "#D1E5F0", 
                         colour = "#2166AC", 
                         outlier.colour = "red", 
                         outlier.size = 2)
    }
    if (isEmpty(jitt_args) & type == "box") {
        jitt_args <- list(col = "#EF8A62", 
                          size = 2, 
                          width = 0.3, 
                          alpha = 0.8)
    }
    if (isEmpty(hline_args) & type == "box") {
        hline_args <- list(yintercept = gwpca$CV$out_up, 
                           linetype = "dashed", 
                           color = "royalblue")
    }
    if (isEmpty(lab_args) & type == "box") {
        labs_args <- list(title = "Local PCs Discrepancy",
                          x = "",
                          y = "Discrepancy score")
    } else if (isEmpty(lab_args) & type == "map") {
        labs_args <- list(title = "Local PCs Discrepancy",
                          fill = "Discrepancy\nscore")
    }
    
    ## List of plots
    plot_list <- list(
        box = function(box_args, jitt_args, hline_args, labs_args, ...){
            ggplot(discs, aes(x = variable, y = value)) + 
                do.call(geom_boxplot, c(list(...), box_args)) +
                do.call(geom_jitter, c(list(...), jitt_args)) +
                do.call(geom_hline, c(list(...), hline_args)) +
                do.call(labs, labs_args) +
                coord_flip() +
                theme_classic() + 
                theme(axis.text.y = element_blank(),
                      axis.ticks.y = element_blank())
        },
        map = function(labs_args, ...){
            ggplot(data = discs) + 
                geom_sf(aes(geometry = geometry, fill = cvs), 
                        colour = NA, ...) +
                geom_sf(aes(geometry = out_geom),
                        fill = alpha("white", 0),
                        colour = "black",
                        linewidth = 0.5) +
                scale_fill_viridis_c(option = "inferno",) +
                do.call(labs, labs_args) +
                theme_void() + 
                theme(legend.position = "right")
        }
    )
    
    ## Get the required plot function
    plot_fun <- plot_list[[type]]
    
    ## Fetch appropriate arguments
    if (type == "box") {
        args_list <- list(box_args = box_args,
                          jitt_args = jitt_args,
                          hline_args = hline_args, 
                          labs_args = labs_args)
    } else if (type == "map") {
        args_list <- list(labs_args = labs_args)
    }
    
    ## Call plot function with appropriate arguments
    plot <- do.call(plot_fun, 
                    c(list(...), args_list))
    
    return(plot)
    
}

# 5. Plot discrepancies: genes heatmap ----
#' @name plotGWPCA_discrHeatmap
#' Plot GWPCA Discrepancy Heatmap
#'
#' Generates a discrepancy heatmap based on GWPCA results for specific tissue 
#' locations.
#'
#' @param sfe SpatialFeatureExperiment object.
#' @param assay Assay type for the spatial expression data (counts, logcounts 
#' etc.).
#' @param vars Variables of interest (genes) to be evaluated. Default is NULL, 
#' which includes all variables.
#' @param focus Tissue locations of interest (barcodes) for which discrepancy 
#' heatmaps will be generated.
#' @param dMetric Distance metric used for generating the distance matrix which
#' will be used to identify the focus location's neighbours.
#' @param sample_id Sample ID for which discrepancy data is retrieved.
#' @param bw Bandwidth parameter for selecting neighbours for the heatmap.
#' @param mean.diff Threshold for selecting genes based on the difference from 
#' the mean discrepancy score.
#' @param show.vars Display option for variables (genes) in the heatmap. Options
#' are "top" (genes with higher discrepancies) or "all" (all genes).
#' @param scale Scaling method for the heatmap. Options are "row" (row scaling) 
#' or "none" (no scaling).
#' @param gene.names Logical indicating whether to display gene names instead of
#' ENSGene IDs.
#' @param ... Additional arguments to be passed to the pheatmap function.
#'
#' @details This function generates discrepancy heatmaps based on GWPCA results 
#' for specific tissue locations (focus). It retrieves the discrepancy data 
#' using the `gwpca_Discrepancy` function, annotates the columns with distance 
#' information, generates annotation colors based on distance levels, and plots 
#' the heatmap using the `pheatmap` function.
#'
#' @examples
#' sfe <- read10xVisiumSFE(samples = sampleDir, sample_id = sampleNames, ...)
#' plotGWPCA_discrHeatmap(sfe, assay = "logcounts", 
#' focus = c(barcode1, barcode2), 
#' dMetric = "euclidean", sample_id = "sample1", 
#' bw = 2, mean.diff = 1, show.vars = "top", scale = "row", gene.names = FALSE)
#'
#' @export
plotGWPCA_discrHeatmap <- function(sfe, 
                                   assay, 
                                   vars = NULL, 
                                   focus, 
                                   dMetric, 
                                   sample_id,
                                   bw, 
                                   mean.diff = 1, 
                                   show.vars = c("top", "all"), 
                                   scale = "row", 
                                   gene.names = FALSE, 
                                   ...) {
    for (i in focus) {
        ## Get the discrepancy data
        dt.focus.list <- getDiscrepancyGeneData(sfe = sfe,
                                                assay = assay,
                                                vars = vars,
                                                focus = i,
                                                dMetric = dMetric,
                                                sample_id = sample_id,
                                                bw = bw,
                                                mean.diff = mean.diff,
                                                exportExpression = FALSE)
        data.focus <- dt.focus.list$data.focus
        
        ## Annotate the columns with distance information
        nbr.annotation <- data.focus %>%
            dplyr::select(Distance)
        
        ## Generate annotation colors based on distance levels
        nbr.lvls <- with(nbr.annotation, table(Distance))
        nbr.ann.colours <- scales::grey_pal(start = 0, end = 0.8)(length(nbr.lvls))
        nbr.ann.colours[1] <- "red" # Make the focus point red
        nbr.ann.colours <- rep(nbr.ann.colours, times = nbr.lvls)
        nbr.ann.colours <- list(Distance = nbr.ann.colours)
        
        ## Drop distance
        data.focus <- data.focus %>% 
            dplyr::select(starts_with("ENSG")) %>%
            t() %>% 
            as.data.frame()
        
        ## Translate the ENSGene IDs to Gene names
        if (gene.names) {
            data.focus <- data.focus  %>% 
                rownames_to_column(var = "id") %>%
                left_join(dt.focus.list$annot) %>% 
                mutate(gene_name = if_else(is.na(gene_name), id, gene_name)) %>%
                column_to_rownames(var = "gene_name") %>% 
                select(ends_with("-1"))
        }
        
        ## Plot the heatmap
        pheatmap(data.focus,
                 scale = scale,
                 annotation_col = nbr.annotation,
                 annotation_colors = nbr.ann.colours,
                 ...)
    }
}

