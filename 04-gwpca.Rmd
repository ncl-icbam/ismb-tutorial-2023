# Practical session 2
In this session we will have a hands-on exploration of GW-PCA and its application to STx data. What can we learn from this novel technique?

## Geographically Weighted Principal Components Analysis (GWPCA)
A standard PCA can pick out the key multivariate modes of variability in the data. Looking at outlying values of the principal components of these data gives us an idea of unusual sites (in terms of combinations of gene expression profiles -and to a certain extend of combinations of cell types in each spot). Next, Geographically weighted PCA can be used to find spatial multivariate outliers. Sounds complicated, but really all this means is it identifies sites that have an unusual multi-way combination of gene expression in relation to their immediate geographical neighbours. It might be that the values observed at these sites as a combination is not uncommon in the tissue as a whole - but is very unusual in its locality.

To find such outliers the procedure is relatively simple - instead of doing a PCA on the tissue as a whole, for each sample we do a PCA on data falling into a window centred on the location of that spot. In that way we can check whether the spot is like its neighbours or not, from a multivariate viewpoint.

The following code carries out a geographically weighted PCA. In short, it runs a ‘windowed’ PCA around each of the spots.

## Load Quality Controled and Normalised data
```{r QC_Norm_LiverData, echo=FALSE, message=FALSE, warning=FALSE, results='hide', eval=FALSE}
## Keep on-tissue spots
colDATA <- inputMD %>%
  dplyr::filter(Section == 1)

## Ground truth from dataset authors
groundTruth <- read.table("./data/spotzonationGroup.txt", header = TRUE)
colDATA <- colDATA %>%
  left_join(groundTruth)

## Get mitochondrial gene names
#biomartHumanGRCh37 <- create_biomart("human", version = "GRCh37")
biomartHumanGRCh37 <- readRDS(file = "./data/biomartHumanGRCh37.rds")
#rowDATA <- annotate_vector(rownames(inputD), biomartHumanGRCh37)
rowDATA <- readRDS(file = "./data/rowData.rds")
is_mito <- grepl("(^MT-)|(^mt-)", rowDATA$gene_name)

## Calculate per-spot QC metrics and store in colData
perCellQC <- perCellQCMetrics(inputD, subsets = list(mito = is_mito)) %>% 
  as.data.frame() %>%
  rownames_to_column(var = "Barcode")
colDATA <- colDATA %>% 
  left_join(perCellQC)

## Calculate size factors
sizeFactor <- librarySizeFactors(inputD) %>% 
  as.data.frame() %>%
  rename("sizeFactor" = ".") %>%
  rownames_to_column(var = "Barcode")
colDATA <- colDATA %>% 
  left_join(sizeFactor)

## Add geometries to colData
colDATA <- colDATA %>% 
  left_join(polygons)

## Select library size threshold
qc_lib_size <- colDATA$sum < 700
colDATA$qc_lib_size <- qc_lib_size
## Select expressed genes threshold
qc_detected <- colDATA$detected < 500
colDATA$qc_detected <- qc_detected
## Select expressed genes threshold
qc_mito <- colDATA$subsets_mito_percent > 24
colDATA$qc_mito <- qc_mito
## Check the number of discarded spots for each metric
apply(cbind(qc_lib_size, qc_detected, qc_mito), 2, sum)
## Combine together the set of discarded spots
discard <- qc_lib_size | qc_detected | qc_mito
## Store the set in the object
colDATA$discard <- discard

## Remove spots that fail to pass the QC
counts <- inputD[,!colDATA$discard]
colDATA <- filter(colDATA, discard == FALSE)

## Normalise counts
sizeFactor <- colDATA$sizeFactor
names(sizeFactor) <- colDATA$Barcode
counts_norm <- normalizeCounts(counts, size.factors = sizeFactor)

## Remove mitochondrial genes
counts_norm <- counts_norm[!is_mito, ]
rowDATA <- rowDATA[!is_mito, ]

## Fit mean-variance relationship
dec <- modelGeneVar(counts_norm)

## Select top HVGs
top_hvgs <- getTopHVGs(dec, prop = 0.1)
rowDATA$topHVGs <- rowDATA$id %in% top_hvgs

## Scale normalised counts 
counts_topHVGs <- counts_norm[rowDATA$topHVGs,]
countsNormCenter <- scale(counts_topHVGs, center = TRUE, scale = FALSE)

## Save
saveRDS(countsNormCenter, file = "./data/countsNormScaled.rds")
saveRDS(rowDATA, file = "./data/rowDATA.rds")
saveRDS(colDATA, file = "./data/colDATA.rds")
```

```{r 04_load_data}
countsNormCenter <- readRDS(file = "./data/countsNormScaled.rds")
rowDATA <- readRDS(file = "./data/rowDATA.rds")
colDATA <- readRDS(file = "./data/colDATA.rds")
```

We imported 3 tables:

1. `countsNormCenter`: normalised and centred counts for the top HVGs without mitochondrial genes. We followed the preprocessing steps from practical session 2.
2. `rowDATA`: Gene annotations (containing, amongst others, ENSG IDs and gene names).
3. `colDATA`: Metadata for the spots that passed the QC as in practical session 2.

```{r 04_prepare_gwpca}
# Prepare for Geographically Weighted PCA (GWPCA)
countsNormCenter <- countsNormCenter %>%
  t() %>%
  as.data.frame() %>% 
  rownames_to_column(var = "rowname") %>%
  arrange("rowname") %>%
  column_to_rownames("rowname")

# Get the coordinates
coords <- colDATA[, c("Barcode", "pixel_x", "pixel_y")] %>%
  arrange(Barcode) %>%
  column_to_rownames(var = "Barcode")

# Get the data into a SpatialPointsDataFrame object
inputPCAgw <- SpatialPointsDataFrame(coords, 
                                     countsNormCenter, 
                                     match.ID = TRUE)

# Identify the most variable genes equal to the number of spots.
# gwpca uses princomp to run the PCAs and this does not accept the number of
# variables (genes) being more than the number of samples (spots).
inputPCAgw <- inputPCAgw[select]
inputPCAgw[1:5, 1:5]
vars <- colnames(inputPCAgw@data)
bw <- 6*spot_diameter(spatialDir)
k <- 20


```

```{r 04_run_gwpca1, eval=FALSE}
pcaGW <- gwpca(inputPCAgw,
                vars = vars,
                bw = bw,
                k = k,
                kernel = "gaussian")
```

Because GWPCA can take some time to run, we ran it for you and below you can load the output.

```{r 04_run_gwpca2}
pcaGW <- readRDS(file = "./data/pcaGW.rds")
```