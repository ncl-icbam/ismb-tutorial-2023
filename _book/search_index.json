[["practical-session-3.html", "Chapter 4 Practical session 3 4.1 Load packages 4.2 Background 4.3 Data structures preparation", " Chapter 4 Practical session 3 This practical session will demonstrate the application of the most commonly used spatial analysis tools to STx data, and how we work with coordinate data alongside expression data. 4.1 Load packages library(spdep) library(sf) library(GWmodel) library(ggplot2) library(tidyverse) spdep is a collection of functions to create spatial weights matrix objects from polygon ‘contiguities’, from point patterns by distance and tessellations, for summarizing these objects, and for permitting their use in spatial data analysis like regional aggregation and tests for spatial ‘autocorrelation’. sf (Simple Features for R) is a package that offers support for simple features, a standardized way to encode spatial vector data. GWmodel is a suit of models that fit situations when data are not described well by some global model, but where there are spatial regions where a suitably localised calibration provides a better description. 4.2 Background 4.2.1 Main geocomputatinal data structures There are three main data structures that we need to have ready before we undertake a geocomputational approach to STx data analysis. Namely these are; (1) geometries (point and polygon), (2) neighbours lists and (3) distance matrices. Spatial geometries can be points, lines, polygons and pixels. Polygons consist of a multitude of points connected by lines and can have many forms like circle, hexagon, non-canonical polygon etc. Neighbour lists are special types of lists that contain information about the neighbours of each polygon. The neighbours can be defined either by adjacency or by distance. Distance matrices contain the distances between different points and can be either weighted or un-weighted. The weighted distances are usually objective to each point and its neighbours. Meaning that the closer or farther a neighbour is from the point of focus, the weight of their distance changes according to an applied kernel. Usually in the case of STx data, like the ones generated by the 10X Visium platform, the un-weighted distance between is two points is in pixels and we acquire it from the spaceranger output. 4.2.2 The sf objects Package sf represents simple features as native R objects. All functions and methods in sf that operate on spatial data are prefixed by st_, which refers to spatial type. Simple features are implemented as R native data, using simple data structures (S3 classes, lists, matrix, vector). Typical use involves reading, manipulating and writing of sets of features, with attributes and geometries. As attributes are typically stored in data.frame objects (or the very similar tbl_df), we will also store feature geometries in a data.frame column. Since geometries are not single-valued, they are put in a list-column, a list of length equal to the number of records in the data.frame, with each list element holding the simple feature geometry of that feature. The three classes used to represent simple features are: sf, the table (data.frame) with feature attributes and feature geometries, which contains sfc, the list-column with the geometries for each feature (record), which is composed of sfg, the feature geometry of an individual simple feature. 4.2.2.1 Simple feature geometry types The following seven simple feature types are the most common: type description POINT zero-dimensional geometry containing a single point LINESTRING sequence of points connected by straight, non-self intersecting line pieces; one-dimensional geometry POLYGON geometry with a positive area (two-dimensional); sequence of points form a closed, non-self intersecting ring; the first ring denotes the exterior ring, zero or more subsequent rings denote holes in this exterior ring MULTIPOINT set of points; a MULTIPOINT is simple if no two Points in the MULTIPOINT are equal MULTILINESTRING set of linestrings MULTIPOLYGON set of polygons GEOMETRYCOLLECTION set of geometries of any type except GEOMETRYCOLLECTION Each of the geometry types can also be a (typed) empty set, containing zero coordinates (for POINT the standard is not clear how to represent the empty geometry). Empty geometries can be thought of being the analogue to missing (NA) attributes, NULL values or empty lists. 4.2.2.2 sf: objects with simple features As we usually do not work with geometries of single simple features, but with datasets consisting of sets of features with attributes, the two are put together in sf (simple feature) objects. The following command reads a test dataset called nc from a file that is contained in the sf package: nc &lt;- st_read(system.file(&quot;shape/nc.shp&quot;, package = &quot;sf&quot;)) ## Reading layer `nc&#39; from data source ## `/Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/library/sf/shape/nc.shp&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 100 features and 14 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 ## Geodetic CRS: NAD27 The short report printed gives the file name, the driver (ESRI Shapefile), mentions that there are 100 features (records, represented as rows) and 14 fields (attributes, represented as columns). This object is of class: class(nc) ## [1] &quot;sf&quot; &quot;data.frame&quot; meaning it extends (and “is” a) data.frame, but with a single list-column with geometries, which is held in the column with name: attr(nc, &quot;sf_column&quot;) ## [1] &quot;geometry&quot; If we print the first three features, we see their attribute values and an abridged version of the geometry print(nc[9:15], n = 3) which would give the following output: Figure 4.1: Overview of the sf object. In the output we see: in green a simple feature: a single record, or data.frame row, consisting of attributes and geometry in blue a single simple feature geometry (an object of class sfg) in red a simple feature list-column (an object of class sfc, which is a column in the data.frame) that although geometries are native R objects, they are printed as well-known text It is also possible to create data.frame objects with geometry list-columns that are not of class sf, e.g. by: nc.no_sf &lt;- as.data.frame(nc) class(nc.no_sf) ## [1] &quot;data.frame&quot; However, such objects: no longer register which column is the geometry list-column no longer have a plot method, and lack all of the other dedicated methods for class sf 4.2.2.3 sfc: simple feature geometry list-column The column in the sf data.frame that contains the geometries is a list, of class sfc. We can retrieve the geometry list-column in this case by using standard data.frame notation like nc$geom or nc[[15]], but the more general way uses st_geometry: (nc_geom &lt;- st_geometry(nc)) ## Geometry set for 100 features ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 ## Geodetic CRS: NAD27 ## First 5 geometries: ## MULTIPOLYGON (((-81.47276 36.23436, -81.54084 3... ## MULTIPOLYGON (((-81.23989 36.36536, -81.24069 3... ## MULTIPOLYGON (((-80.45634 36.24256, -80.47639 3... ## MULTIPOLYGON (((-76.00897 36.3196, -76.01735 36... ## MULTIPOLYGON (((-77.21767 36.24098, -77.23461 3... Geometries are printed in abbreviated form, but we can view a complete geometry by selecting it, e.g. the first one by: nc_geom[[1]] ## MULTIPOLYGON (((-81.47276 36.23436, -81.54084 36.27251, -81.56198 36.27359, -81.63306 36.34069, -81.74107 36.39178, -81.69828 36.47178, -81.7028 36.51934, -81.67 36.58965, -81.3453 36.57286, -81.34754 36.53791, -81.32478 36.51368, -81.31332 36.4807, -81.26624 36.43721, -81.26284 36.40504, -81.24069 36.37942, -81.23989 36.36536, -81.26424 36.35241, -81.32899 36.3635, -81.36137 36.35316, -81.36569 36.33905, -81.35413 36.29972, -81.36745 36.2787, -81.40639 36.28505, -81.41233 36.26729, -81.43104 36.26072, -81.45289 36.23959, -81.47276 36.23436))) The way this is printed is called well-known text, and is part of the standards. The word MULTIPOLYGON is followed by three parentheses, because it can consist of multiple polygons, in the form of MULTIPOLYGON(POL1,POL2), where POL1 might consist of an exterior ring and zero or more interior rings, as of (EXT1,HOLE1,HOLE2). Sets of coordinates are held together with parentheses, so we get ((crds_ext)(crds_hole1)(crds_hole2)) where crds_ is a comma-separated set of coordinates of a ring. This leads to the case above, where MULTIPOLYGON(((crds_ext))) refers to the exterior ring (1), without holes (2), of the first polygon (3) - hence three parentheses. We can see there is a single polygon with no rings: par(mar = c(0,0,1,0)) plot(nc[1], reset = FALSE) # reset = FALSE: we want to add to a plot with a legend plot(nc[1,1], col = &#39;grey&#39;, add = TRUE) Following the MULTIPOLYGON data structure, in R we have a list of lists of lists of matrices. For instance, we get the first 3 coordinate pairs of the second exterior ring (first ring is always exterior) for the geometry of feature 4 by: nc_geom[[4]][[2]][[1]][1:3,] ## [,1] [,2] ## [1,] -76.02717 36.55672 ## [2,] -75.99866 36.55665 ## [3,] -75.91192 36.54253 Geometry columns have their own class, class(nc_geom) ## [1] &quot;sfc_MULTIPOLYGON&quot; &quot;sfc&quot; 4.2.2.4 sfg: simple feature geometry Simple feature geometry (sfg) objects carry the geometry for a single feature, e.g. a point, linestring or polygon. Simple feature geometries are implemented as R native data, using the following rules a single POINT is a numeric vector a set of points, e.g. in a LINESTRING or ring of a POLYGON is a matrix, each row containing a point any other set is a list The below figure illustrates the different types of geometries: Geometries can also be empty, as in (x &lt;- st_geometrycollection()) ## GEOMETRYCOLLECTION EMPTY length(x) ## [1] 0 The above are taken from the very well written, well-descriptive and thorough sf package vignette. 4.3 Data structures preparation For this practical we will be using a human steatotic kidney dataset from the Liver Atlas (Guilliams et al. 2022). 4.3.1 Load new dataset First we load the counts table with genes in rows and spots in columns. ## Load counts table inputD &lt;- readRDS(file = &quot;./data/hsLivSteat_JBO019_inputD.rds&quot;) inputD[1:5, 1:3] ## AAACAAGTATCTCCCA.1 AAACATTTCCCGGATT.1 AAACCCGAACGAAATC.1 ## ENSG00000243485 0 0 0 ## ENSG00000237613 0 0 0 ## ENSG00000186092 0 0 0 ## ENSG00000238009 0 0 0 ## ENSG00000239945 0 0 0 Then we load the spot metadata. The imported table has the below columns: Barcode: the spot barcode (note that we substituted the “-” with a “.” to match the column names in the inputD because it is not good practise to have “-” in column names in R). Section: whether the spot is on- or off- tissue (on-tissue = 1, off-tissue = 0). Spot_Y/ Spot_X: X and Y spot location on the capture area array. Image_Y/ Image_X: X and Y spot coordinates in the full resolution image. pixel_x/ pixel_y: X and Y spot coordinates in the low resolution image. ## Load spot metadata inputMD &lt;- readRDS(file = &quot;./data/hsLivSteat_JBO019_inputMD.rds&quot;) head(inputMD) ## Barcode Section Spot_Y Spot_X Image_Y Image_X pixel_x pixel_y ## 1 ACGCCTGACACGCGCT.1 0 0 0 16961 2500 68.85156 467.1165 ## 2 TACCGATCCAACACTT.1 0 1 1 16847 2696 74.24952 463.9769 ## 3 ATTAAAGCGGACGAGC.1 0 0 2 16735 2499 68.82401 460.8923 ## 4 GATAAGGGACGATTAG.1 0 1 3 16621 2695 74.22198 457.7527 ## 5 GTGCAAATCACCAATA.1 0 0 4 16509 2497 68.76893 454.6681 ## 6 TGTTGGCTGGCGGAAG.1 0 1 5 16395 2693 74.16690 451.5285 4.3.2 Create point geometries First we want to extract the pixel coordinates from the inputMD data frame and then we will generate the point geometries (centroids) from all spots of the 10X Visium capture area. This helps to tessellate space better in the next step. ## Extract coordinates spot_position &lt;- inputMD %&gt;% select(c(&quot;Barcode&quot;, &quot;pixel_x&quot;, &quot;pixel_y&quot;, &quot;Section&quot;)) head(spot_position, 5) ## Barcode pixel_x pixel_y Section ## 1 ACGCCTGACACGCGCT.1 68.85156 467.1165 0 ## 2 TACCGATCCAACACTT.1 74.24952 463.9769 0 ## 3 ATTAAAGCGGACGAGC.1 68.82401 460.8923 0 ## 4 GATAAGGGACGATTAG.1 74.22198 457.7527 0 ## 5 GTGCAAATCACCAATA.1 68.76893 454.6681 0 ## Convert spots to centroids centroids &lt;- spot_position %&gt;% st_as_sf(coords = c(&quot;pixel_x&quot;, &quot;pixel_y&quot;), remove = FALSE) head(centroids, 5) ## Simple feature collection with 5 features and 4 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 68.76893 ymin: 454.6681 xmax: 74.24952 ymax: 467.1165 ## CRS: NA ## Barcode pixel_x pixel_y Section geometry ## 1 ACGCCTGACACGCGCT.1 68.85156 467.1165 0 POINT (68.85156 467.1165) ## 2 TACCGATCCAACACTT.1 74.24952 463.9769 0 POINT (74.24952 463.9769) ## 3 ATTAAAGCGGACGAGC.1 68.82401 460.8923 0 POINT (68.82401 460.8923) ## 4 GATAAGGGACGATTAG.1 74.22198 457.7527 0 POINT (74.22198 457.7527) ## 5 GTGCAAATCACCAATA.1 68.76893 454.6681 0 POINT (68.76893 454.6681) 4.3.3 Tesselate space Here we will take the steps towards tessellating space. This tessellation, brakes the area that surrounds the spots and as a result we can use it to find neighbours by adjacency later on. We need to always keep in mind that although tessellation makes the spots have common borders, the 10X Visium spots have a distance between them that is approximately 50μm. First, we combine the points we calculated earlier into a multipoint geometry. Second, we tessellate space around the points using the Voronoi tessellation. Third, we can cut the tessellation around the edges because tessellation extends to infinity. ## Combine the points into a multipoint geometry: cntd_union &lt;- st_union(centroids) head(cntd_union) ## Geometry set for 1 feature ## Geometry type: MULTIPOINT ## Dimension: XY ## Bounding box: xmin: 66.45552 ymin: 69.04434 xmax: 486.1195 ymax: 467.1165 ## CRS: NA ## MULTIPOINT ((66.45552 74.69017), (66.5106 80.91... ## Use the union of points to generate a voronoi object voronoi &lt;- st_voronoi(cntd_union, bOnlyEdges = TRUE) head(voronoi) ## Geometry set for 1 feature ## Geometry type: MULTILINESTRING ## Dimension: XY ## Bounding box: xmin: -353.2085 ymin: -350.6197 xmax: 905.7835 ymax: 886.7805 ## CRS: NA ## MULTILINESTRING ((68.32756 84.03226, 70.14669 8... ## Create an enveloped voronoi tessellation around the tissue voronoi_env &lt;- st_intersection(st_cast(voronoi), st_convex_hull(cntd_union)) head(voronoi_env) ## Geometry set for 1 feature ## Geometry type: MULTILINESTRING ## Dimension: XY ## Bounding box: xmin: 66.47385 ymin: 69.06262 xmax: 486.1006 ymax: 467.0982 ## CRS: NA ## MULTILINESTRING ((68.32756 84.03226, 70.14669 8... ## Plot tessellation as is ggplot(data = voronoi) + geom_sf() + labs(title = &quot;Tessellation&quot;) + theme_void() ## Plot enveloped tessellation ggplot(data = voronoi_env) + geom_sf() + labs(title = &quot;Tessellation cut to capture area&quot;) + theme_void() 4.3.4 Polygonise the tessellation Here we will extract polygons from the tessellation object only for the spots that are on-tissue. Meaning, they have a value of 1 in the Section column. ## Generate the POLYGONS from the MULTILINESTRING polygons &lt;- st_polygonize(voronoi_env) %&gt;% # polygonise the tessellation st_cast() %&gt;% # convert GEOMETRYCOLLECTION to multiple POLYGONS st_sf() %&gt;% # convert sfc object to sf for st_join afterwards st_join(., centroids[centroids$Section == 1,], join = st_contains, left = FALSE) %&gt;% rename(geom_pol = geometry) %&gt;% # Join the centroids with the POLYGONS mutate(Barcode_rn = Barcode) %&gt;% # duplicate the barcode column column_to_rownames(&quot;Barcode_rn&quot;) %&gt;% # move duplicate column to row names st_sf() # convert back to sf (mutate makes it a df) head(polygons) ## Simple feature collection with 6 features and 4 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: 106.5067 ymin: 121.1432 xmax: 201.425 ymax: 304.4226 ## CRS: NA ## Barcode pixel_x pixel_y Section ## AAACTAACGTGGCGAC.1 AAACTAACGTGGCGAC.1 110.1074 124.2633 1 ## GACTAAGATCATGCAC.1 GACTAAGATCATGCAC.1 192.4814 301.2944 1 ## ATCGACTCTTTCCGTT.1 ATCGACTCTTTCCGTT.1 192.3437 276.3701 1 ## TGGTTCGTAGCAAAGG.1 TGGTTCGTAGCAAAGG.1 192.4539 295.0702 1 ## GCTCTAAACCCTGACG.1 GCTCTAAACCCTGACG.1 197.8243 285.6789 1 ## TCAAACAACCGCGTCG.1 TCAAACAACCGCGTCG.1 197.7692 279.4547 1 ## geom_pol ## AAACTAACGTGGCGAC.1 POLYGON ((108.2826 121.1592... ## GACTAAGATCATGCAC.1 POLYGON ((188.8807 301.3139... ## ATCGACTCTTTCCGTT.1 POLYGON ((190.496 273.2742,... ## TGGTTCGTAGCAAAGG.1 POLYGON ((190.6062 291.9742... ## GCTCTAAACCCTGACG.1 POLYGON ((195.9765 282.5829... ## TCAAACAACCGCGTCG.1 POLYGON ((194.1607 279.4881... As you may have observed we joined the polygons object with the centroids object so that we can add the rest of the information like Barcode, pixel_x, and pixel_y. If we plot it: ## Plot on tissue polygons ggplot(data = polygons) + geom_sf(aes(geometry = geom_pol)) + theme_void() Because there are times that we will need the polygons and times that we will need their centroids we can add both geometries in the polygons object. ## Update the polygon object to keep the centroid geometries as well polygons &lt;- polygons %&gt;% # rename polygons geom column left_join(as.data.frame(centroids)) %&gt;% # left joint pols and cntds rename(geom_cntd = geometry) %&gt;% # rename centroids geom column st_sf(sf_column_name = &quot;geom_pol&quot;) # set polygons geom column to be the default (one must be) head(polygons) ## Simple feature collection with 6 features and 4 fields ## Active geometry column: geom_pol ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: 106.5067 ymin: 121.1432 xmax: 201.425 ymax: 304.4226 ## CRS: NA ## Barcode pixel_x pixel_y Section geom_pol ## 1 AAACTAACGTGGCGAC.1 110.1074 124.2633 1 POLYGON ((108.2826 121.1592... ## 2 GACTAAGATCATGCAC.1 192.4814 301.2944 1 POLYGON ((188.8807 301.3139... ## 3 ATCGACTCTTTCCGTT.1 192.3437 276.3701 1 POLYGON ((190.496 273.2742,... ## 4 TGGTTCGTAGCAAAGG.1 192.4539 295.0702 1 POLYGON ((190.6062 291.9742... ## 5 GCTCTAAACCCTGACG.1 197.8243 285.6789 1 POLYGON ((195.9765 282.5829... ## 6 TCAAACAACCGCGTCG.1 197.7692 279.4547 1 POLYGON ((194.1607 279.4881... ## geom_cntd ## 1 POINT (110.1074 124.2633) ## 2 POINT (192.4814 301.2944) ## 3 POINT (192.3437 276.3701) ## 4 POINT (192.4539 295.0702) ## 5 POINT (197.8243 285.6789) ## 6 POINT (197.7692 279.4547) As we can see here we have two geometry columns; one named geom_pol and one named geom_cntd. As a result we need to have one of these two as the active geometry column for the polygons object of class sf. We can see at the top of the printed output that the active geometry column is geom_pol. In general we can switch between geometry columns using: st_geometry(sf_object) &lt;- \"geom_column_to_change_to\" 4.3.5 Identify neighbours 4.3.5.1 By contiguity We can contiguity-based neighbours for each spot using the poly2nb function from spdep. The function is using heuristics to identify polygons sharing boundary points as neighbours. It also has a snap = argument, to allow the shared boundary points to be a short distance from one another. Here we select snap = 0 because the tessellation generated polygons with shared borders. Finally, the queen = argument is set to TRUE. This means that the function will look for a chess queen-style of contiguities. ## Get contiguity neighbours nb_adjc &lt;- poly2nb(pl = polygons, snap = 0, queen = TRUE) length(nb_adjc) ## [1] 1184 head(nb_adjc) ## [[1]] ## [1] 0 ## ## [[2]] ## [1] 4 7 11 ## ## [[3]] ## [1] 6 10 ## ## [[4]] ## [1] 2 7 8 ## ## [[5]] ## [1] 6 8 12 15 ## ## [[6]] ## [1] 3 5 10 12 13 nb_adjc_n &lt;- card(nb_adjc) ggplot() + geom_histogram(aes(x = nb_adjc_n, y = after_stat(density)), colour = &quot;black&quot;, fill = &quot;grey&quot;) + geom_density(aes(x = nb_adjc_n), alpha = 0.5, adjust = 0.5, fill = &quot;#A0CBE8&quot;, colour = &quot;#4E79A7&quot;) + scale_x_continuous(breaks = scales::pretty_breaks(n = 6)) + scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) + xlab(&quot;Number of Neighbours&quot;) + theme_classic() ggplot() + geom_sf(data = polygons, aes(geometry = geom_pol), colour = &quot;grey30&quot;, fill = &quot;white&quot;) + geom_sf(data = as(nb2lines(nb_adjc, coords = polygons$geom_cntd), &quot;sf&quot;), colour = &quot;black&quot;, linewidth = 0.25) + geom_sf(data = polygons, aes(geometry = geom_cntd), colour = &quot;black&quot;, size = 1) + theme_void() As you can see, the neighbours object is a list of length equal to the number of spots we have in the dataset. Each element of the list represents a spot and the numbers stored inside the indexes of the neighbouring spots and the spots have a different numbers of neighbours. The connectivity histogram visualises the distribution of the number of neighbours in the data. 4.3.5.2 By graph Once representative points are available, the criteria for neighbourhood can be extended from just contiguity to include graph measures, distance thresholds, and 𝑘-nearest neighbours. The most direct graph representation of neighbours is to make a Delaunay triangulation of the points, which extends outwards to the convex hull of the points. Note that graph-based representations construct the interpoint relationships based on Euclidean distance. Because it joins distant points around the convex hull, it may be worthwhile to thin the triangulation as a Sphere of Influence (SOI) graph, removing links that are relatively long. Points are SOI neighbours if circles centred on the points, of radius equal to the points’ nearest neighbour distances, intersect in two places (Avis and Horton 1985). ## Set centroids as default geometry st_geometry(polygons) &lt;- &quot;geom_cntd&quot; ## Get the neighbour names nb_names &lt;- polygons$Barcode ## By Delaunay triangulation nb_tri &lt;- tri2nb(polygons$geom_cntd, row.names = nb_names) length(nb_tri) ## [1] 1184 head(nb_tri) ## [[1]] ## [1] 2 3 4 52 53 61 71 78 79 80 81 82 83 84 85 86 88 91 103 ## [20] 155 ## ## [[2]] ## [1] 1 4 7 9 11 ## ## [[3]] ## [1] 1 4 5 6 10 35 61 ## ## [[4]] ## [1] 1 2 3 5 7 8 ## ## [[5]] ## [1] 3 4 6 8 12 15 ## ## [[6]] ## [1] 3 5 10 12 13 nb_tri_n &lt;- card(nb_tri) ggplot() + geom_histogram(aes(x = nb_tri_n, y = after_stat(density)), colour = &quot;black&quot;, fill = &quot;grey&quot;) + geom_density(aes(x = nb_tri_n), alpha = 0.5, adjust = 0.5, fill = &quot;#A0CBE8&quot;, colour = &quot;#4E79A7&quot;) + scale_x_continuous(breaks = scales::pretty_breaks(n = 10)) + scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) + xlab(&quot;Number of Neighbours&quot;) + theme_classic() ggplot() + geom_sf(data = polygons, aes(geometry = geom_pol), colour = &quot;grey30&quot;, fill = &quot;white&quot;) + geom_sf(data = as(nb2lines(nb_tri, coords = polygons$geom_cntd), &quot;sf&quot;), colour = &quot;black&quot;, linewidth = 0.25) + geom_sf(data = polygons, aes(geometry = geom_cntd), colour = &quot;black&quot;, size = 1) + theme_void() ## Get neighbours by SOI nb_soi &lt;- graph2nb(soi.graph(nb_tri, polygons$geom_cntd), row.names = nb_names) length(nb_soi) ## [1] 1184 head(nb_soi) ## [[1]] ## [1] 52 53 78 79 ## ## [[2]] ## [1] 4 7 9 11 ## ## [[3]] ## [1] 5 6 10 ## ## [[4]] ## [1] 2 5 7 8 ## ## [[5]] ## [1] 3 4 6 8 12 15 ## ## [[6]] ## [1] 3 5 10 12 13 nb_soi_n &lt;- card(nb_soi) ggplot() + geom_histogram(aes(x = nb_soi_n, y = after_stat(density)), colour = &quot;black&quot;, fill = &quot;grey&quot;) + geom_density(aes(x = nb_soi_n), alpha = 0.5, adjust = 0.5, fill = &quot;#A0CBE8&quot;, colour = &quot;#4E79A7&quot;) + scale_x_continuous(breaks = scales::pretty_breaks(n = 8)) + scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) + xlab(&quot;Number of Neighbours&quot;) + theme_classic() ggplot() + geom_sf(data = polygons, aes(geometry = geom_pol), colour = &quot;grey30&quot;, fill = &quot;white&quot;) + geom_sf(data = as(nb2lines(nb_soi, coords = polygons$geom_cntd), &quot;sf&quot;), colour = &quot;black&quot;, linewidth = 0.25) + geom_sf(data = polygons, aes(geometry = geom_cntd), colour = &quot;black&quot;, size = 1) + theme_void() ## Get neighbours by Gabriel graph nb_gbn &lt;- graph2nb(gabrielneigh(polygons$geom_cntd), row.names = nb_names) length(nb_gbn) ## [1] 1184 head(nb_gbn) ## [[1]] ## [1] 53 ## ## [[2]] ## [1] 4 7 11 ## ## [[3]] ## [1] 6 10 ## ## [[4]] ## [1] 7 8 ## ## [[5]] ## [1] 6 8 12 15 ## ## [[6]] ## [1] 10 12 13 nb_gbn_n &lt;- card(nb_gbn) ggplot() + geom_histogram(aes(x = nb_gbn_n, y = after_stat(density)), colour = &quot;black&quot;, fill = &quot;grey&quot;) + geom_density(aes(x = nb_gbn_n), alpha = 0.5, adjust = 0.5, fill = &quot;#A0CBE8&quot;, colour = &quot;#4E79A7&quot;) + scale_x_continuous(breaks = scales::pretty_breaks(n = 4)) + scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) + xlab(&quot;Number of Neighbours&quot;) + theme_classic() ggplot() + geom_sf(data = polygons, aes(geometry = geom_pol), colour = &quot;grey30&quot;, fill = &quot;white&quot;) + geom_sf(data = as(nb2lines(nb_gbn, coords = polygons$geom_cntd), &quot;sf&quot;), colour = &quot;black&quot;, linewidth = 0.25) + geom_sf(data = polygons, aes(geometry = geom_cntd), colour = &quot;black&quot;, size = 1) + theme_void() ## Get Relative graph neighbours nb_rn &lt;- graph2nb(relativeneigh(polygons$geom_cntd), row.names = nb_names) length(nb_rn) ## [1] 1184 head(nb_rn) ## [[1]] ## [1] 53 ## ## [[2]] ## [1] 4 ## ## [[3]] ## [1] 6 ## ## [[4]] ## [1] 7 ## ## [[5]] ## [1] 6 8 15 ## ## [[6]] ## [1] 10 nb_rn_n &lt;- card(nb_rn) ggplot() + geom_histogram(aes(x = nb_rn_n, y = after_stat(density)), colour = &quot;black&quot;, fill = &quot;grey&quot;) + geom_density(aes(x = nb_rn_n), alpha = 0.5, adjust = 0.5, fill = &quot;#A0CBE8&quot;, colour = &quot;#4E79A7&quot;) + scale_x_continuous(breaks = scales::pretty_breaks(n = 10)) + scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) + xlab(&quot;Number of Neighbours&quot;) + theme_classic() ggplot() + geom_sf(data = polygons, aes(geometry = geom_pol), colour = &quot;grey30&quot;, fill = &quot;white&quot;) + geom_sf(data = as(nb2lines(nb_rn, coords = polygons$geom_cntd), &quot;sf&quot;), colour = &quot;black&quot;, linewidth = 0.25) + geom_sf(data = polygons, aes(geometry = geom_cntd), colour = &quot;black&quot;, size = 1) + theme_void() Delaunay triangulation neighbours and SOI neighbours are symmetric by design – if 𝑖 is a neighbour of 𝑗, then 𝑗 is a neighbour of 𝑖. The Gabriel graph is also a subgraph of the Delaunay triangulation, retaining a different set of neighbours (Matula and Sokal 1980). It does not, however, guarantee symmetry; the same applies to Relative graph neighbours (Toussaint 1980). 4.3.5.3 By distance An alternative method is to choose the 𝑘 nearest points as neighbours – this adapts across the study area, taking account of differences in the densities of areal entities. Naturally, in the overwhelming majority of cases, it leads to asymmetric neighbours, but will ensure that all areas have 𝑘 neighbours. ## Set centroids as default geometry st_geometry(polygons) &lt;- &quot;geom_cntd&quot; ## Get distance-based neighbours nb_knn &lt;- knn2nb(knearneigh(polygons, k = 6), row.names = nb_names) length(nb_knn) ## [1] 1184 head(nb_knn) ## [[1]] ## [1] 52 53 74 76 77 78 ## ## [[2]] ## [1] 4 7 8 9 11 19 ## ## [[3]] ## [1] 5 6 10 12 13 18 ## ## [[4]] ## [1] 2 5 7 8 11 14 ## ## [[5]] ## [1] 6 8 12 13 14 15 ## ## [[6]] ## [1] 3 5 10 12 13 18 ggplot() + geom_sf(data = polygons, aes(geometry = geom_pol), colour = &quot;grey30&quot;, fill = &quot;white&quot;) + geom_sf(data = as(nb2lines(nb_knn, coords = polygons$geom_cntd), &quot;sf&quot;), colour = &quot;black&quot;, linewidth = 0.25) + geom_sf(data = polygons, aes(geometry = geom_cntd), colour = &quot;black&quot;, size = 1) + theme_void() As you can see, this neighbours object is also a list of length equal to the number of spots we have in the dataset with the same content as the one earlier. Also, in this list all spots have the same number of neighbours since we selected k = 6 which means we have the 6 nearest by distance spots. Another interesting fact here is that spots that are not adjacent to each other now might be neighbours. Another way to find neighbours by distance is to first generate a graph for k = 1. This way we can find the shortest and the longest distance needed for a spot to acquire one neighbour. Then, we can use another function called dnearneigh which is used to find neighbours with an interpoint distance, with arguments d1 and d2 setting the lower and upper distance bounds. There as a lower bound we can provide zero or the shortest distance a neighbour is found in our dataset and as an upper bound we can provide a value that is a function of the largest distance a neighbour is found in our dataset. ## Get distance-based neighbours for k = 1 nb_1nn &lt;- knn2nb(knearneigh(polygons, k = 1), row.names = nb_names) dsts &lt;- unlist(nbdists(nb_1nn, polygons$geom_cntd)) summary(dsts) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 6.224 6.224 6.224 6.320 6.224 114.870 max_1nn &lt;- max(dsts) min_1nn &lt;- min(dsts) As you can see, because the 10X Visium spots are equidistant, the majority of the distances is around 6 pixels. Additionally, the maximum distance is almost 20 times the minimum. This is due to the one spot we keep having on the left of our tissue area. As a result in our dataset we will use as upper bound a value that is a function of the minimum distance instead of the maximum. Let’s have a look at how the dataset looks with the maximum as upper boundary nb_1nna &lt;- dnearneigh(polygons$geom_cntd, d1 = 0, d2 = 1*max_1nn, row.names = nb_names) str(nb_1nna[1:5]) ## List of 5 ## $ : int 53 ## $ : int [1:334] 3 4 5 6 7 8 9 10 11 12 ... ## $ : int [1:387] 2 4 5 6 7 8 9 10 11 12 ... ## $ : int [1:347] 2 3 5 6 7 8 9 10 11 12 ... ## $ : int [1:392] 2 3 4 6 7 8 9 10 11 12 ... nb_1nna_n &lt;- card(nb_1nna) ggplot() + geom_histogram(aes(x = nb_1nna_n, y = after_stat(density)), colour = &quot;black&quot;, fill = &quot;grey&quot;) + geom_density(aes(x = nb_1nna_n), alpha = 0.5, adjust = 0.5, fill = &quot;#A0CBE8&quot;, colour = &quot;#4E79A7&quot;) + scale_x_continuous(breaks = scales::pretty_breaks(n = 10)) + scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) + xlab(&quot;Number of Neighbours&quot;) + theme_classic() As you can see, the number of neighbours each spot acquires because we use the maximum distance as the upper bound is massive and as a result it will not plot correctly. nb_1nnb &lt;- dnearneigh(polygons$geom_cntd, d1 = 0, d2 = 1*min_1nn, row.names = nb_names) nb_1nnc &lt;- dnearneigh(polygons$geom_cntd, d1 = 0, d2 = 1.5*min_1nn, row.names = nb_names) nb_1nnd &lt;- dnearneigh(polygons$geom_cntd, d1 = 0, d2 = 1.75*min_1nn, row.names = nb_names) ps &lt;- grep(&quot;nn[b,c,d]&quot;, names(.GlobalEnv), value = TRUE) for (p in ps) { q &lt;- get(p) (ggplot() + geom_sf(data = polygons, aes(geometry = geom_pol), colour = &quot;grey30&quot;, fill = &quot;white&quot;) + geom_sf(data = as(nb2lines(q, coords = polygons$geom_cntd), &quot;sf&quot;), colour = &quot;black&quot;, linewidth = 0.1) + geom_sf(data = polygons, aes(geometry = geom_cntd), colour = &quot;black&quot;, size = 0.25) + labs(title = p) + theme_void()) %&gt;% print() } for(p in ps) { q &lt;- get(p) q_n &lt;- card(q) (ggplot() + geom_histogram(aes(x = q_n, y = after_stat(density)), colour = &quot;black&quot;, fill = &quot;grey&quot;) + geom_density(aes(x = q_n), alpha = 0.5, adjust = 0.5, fill = &quot;#A0CBE8&quot;, colour = &quot;#4E79A7&quot;) + scale_x_continuous(breaks = scales::pretty_breaks(n = 10)) + scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) + labs(title = p, x = &quot;Number of Neighbours&quot;) + theme_classic()) %&gt;% print() } ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Using the maximum as the upper limit is not prohibited, it is just not advised if you plan to plot the neighbour relationships on a map. The above for identifying neighbours are partially taken from the very well written, well-descriptive and thorough spdep package vignette for neighbours identification. 4.3.5.4 Adding spatial weights The neighbour lists can be supplemented with spatial weights using the nb2listw and nb2listwdist function from spdep package for the chosen type and coding scheme style. There are 6 different coding scheme styles that can be used to weigh neighbour relationships: B: is the basic binary coding (1 for neighbour, 0 for no neighbour). W: is row standardised (sums over all links to n). C: is globally standardised (sums over all links to n). U: is equal to C divided by the number of neighbours (sums over all links to unity). S: is the variance-stabilizing coding scheme (sums over all links to n). minmax: divides the weights by the minimum of the maximum row sums and maximum column sums of the input weights; It is similar to the C and U styles. The coding scheme style is practically the value each neighbour will get. For example, in a binary coding scheme style (B) if a spot is a neighbour of the spot in focus then gets the value of 1, else gets 0. Another example, in a row standardised coding scheme style (W) if the spot in focus has a total of 10 neighbours and each neighbour has a weight of 1, then the sum of all neighbour weights is 10, and each neighbour will get a normalised weight of 1/10 = 0.1. As a result, in the row standardised coding scheme, spots with many neighbours will have neighbours with lower weights and thus will not be over-emphasised. Starting from a binary neighbours list, in which regions are either listed as neighbours or are absent (thus not in the set of neighbours for some definition), we can add a distance-based weights list. The nb2listwdist function supplements a neighbours list with spatial weights for the chosen types of distance modelling and coding scheme. While the offered coding schemes parallel those of the nb2listw function above, three distance-based types of weights are available: inverse distance weighting (IDW), double-power distance weights (DPD), and exponential distance decay (EXP). The three types of distance weight calculations are based on pairwise distances 𝑑𝑖𝑗, all of which are controlled by parameter “alpha” (𝛼 below): idw: 𝑤𝑖𝑗=𝑑−𝛼𝑖𝑗, exp: 𝑤𝑖𝑗=exp(−𝛼⋅𝑑𝑖𝑗), dpd: 𝑤𝑖𝑗=[1−(𝑑𝑖𝑗/𝑑max)𝛼]𝛼, the latter of which leads to 𝑤𝑖𝑗=0 for all 𝑑𝑖𝑗&gt;𝑑max. Note that IDW weights show extreme behaviour close to 0 and can take on the value infinity. In such cases, the infinite values are replaced by the largest finite weight present in the weights list. The default coding scheme for nb2listwdist is “raw”, which outputs the raw distance-based weights without applying any kind of normalisation. In addition, the same coding scheme styles that are also available in the nb2listw function can be chosen. Below we will use only the nb2listwdist function which can accommodate both weight types and coding scheme styles. ## Set centroids as default geometry st_geometry(polygons) &lt;- &quot;geom_cntd&quot; ## Add weights nb_adjc_w &lt;- nb2listwdist(nb_adjc, polygons, type = &quot;idw&quot;, style = &quot;W&quot;, zero.policy = TRUE) ## Have a look nb_adjc_w$weights[1:5] ## [[1]] ## NULL ## ## [[2]] ## [1] 0.3344222 0.3333309 0.3322469 ## ## [[3]] ## [1] 0.5001435 0.4998565 ## ## [[4]] ## [1] 0.3339962 0.3330975 0.3329063 ## ## [[5]] ## [1] 0.2506436 0.2495468 0.2498330 0.2499765 4.3.6 Generate distance matrices A distance matrix is a mirrored matrix that contains the distance between a spot and every other spot. This distance can be weighted according to a bandwidth around each spot using a kernel that gives higher scores to distances between spots that are closer together compared to the ones that are farther away. These weighted distance matrices are later used to run geographically weighted (GW) models. There are 6 different kernels that can be used to weight the distances between spots. The next two figures are from the GWmodel’s publication (Gollini et al. 2015) and provide a bit more description on that. (#fig:GWmodel_fig1)The math equations that define the kernels. (#fig:GWmodel_fig2)Examples from using each kernel. ## Set centroids as default geometry st_geometry(polygons) &lt;- &quot;geom_cntd&quot; ## Get Euclidean distances between spots dist.Mat &lt;- gw.dist(dp.locat = st_coordinates(polygons), p = 2) rownames(dist.Mat) &lt;- nb_names colnames(dist.Mat) &lt;- nb_names dist.Mat[1:5, 1:4] ## AAACTAACGTGGCGAC.1 GACTAAGATCATGCAC.1 ATCGACTCTTTCCGTT.1 ## AAACTAACGTGGCGAC.1 0.0000 195.257504 172.91415 ## GACTAAGATCATGCAC.1 195.2575 0.000000 24.92464 ## ATCGACTCTTTCCGTT.1 172.9142 24.924643 0.00000 ## TGGTTCGTAGCAAAGG.1 189.6205 6.224242 18.70041 ## GCTCTAAACCCTGACG.1 183.7097 16.504279 10.80228 ## TGGTTCGTAGCAAAGG.1 ## AAACTAACGTGGCGAC.1 189.620541 ## GACTAAGATCATGCAC.1 6.224242 ## ATCGACTCTTTCCGTT.1 18.700407 ## TGGTTCGTAGCAAAGG.1 0.000000 ## GCTCTAAACCCTGACG.1 10.818453 ## Set bandwidth bw = (range(dist.Mat)[2])/2 bw ## [1] 165.0985 ## Select a kernel kernel = &quot;bisquare&quot; ## Calculate W distance matrix w &lt;- gw.weight(vdist = dist.Mat, bw = bw, kernel = kernel, adaptive = FALSE) rownames(w) &lt;- nb_names colnames(w) &lt;- nb_names w[1:5, 1:4] ## AAACTAACGTGGCGAC.1 GACTAAGATCATGCAC.1 ATCGACTCTTTCCGTT.1 ## AAACTAACGTGGCGAC.1 1 0.0000000 0.0000000 ## GACTAAGATCATGCAC.1 0 1.0000000 0.9549366 ## ATCGACTCTTTCCGTT.1 0 0.9549366 1.0000000 ## TGGTTCGTAGCAAAGG.1 0 0.9971594 0.9745052 ## GCTCTAAACCCTGACG.1 0 0.9801134 0.9914563 ## TGGTTCGTAGCAAAGG.1 ## AAACTAACGTGGCGAC.1 0.0000000 ## GACTAAGATCATGCAC.1 0.9971594 ## ATCGACTCTTTCCGTT.1 0.9745052 ## TGGTTCGTAGCAAAGG.1 1.0000000 ## GCTCTAAACCCTGACG.1 0.9914308 4.3.7 Putting it all together The below code puts all these steps in order by selecting one of the options at each step. ## Load data and metadata inputD &lt;- readRDS(file = &quot;./data/hsLivSteat_JBO019_inputD.rds&quot;) inputMD &lt;- readRDS(file = &quot;./data/hsLivSteat_JBO019_inputMD.rds&quot;) ## Create point geometries spot_position &lt;- inputMD %&gt;% select(c(&quot;Barcode&quot;, &quot;pixel_x&quot;, &quot;pixel_y&quot;, &quot;Section&quot;)) centroids &lt;- spot_position %&gt;% st_as_sf(coords = c(&quot;pixel_x&quot;, &quot;pixel_y&quot;), remove = FALSE) ## Tessellate space cntd_union &lt;- st_union(centroids) voronoi &lt;- st_voronoi(cntd_union, bOnlyEdges = TRUE) voronoi_env &lt;- st_intersection(st_cast(voronoi), st_convex_hull(cntd_union)) ## Polygonise tessellation polygons &lt;- st_polygonize(voronoi_env) %&gt;% st_cast() %&gt;% st_sf() %&gt;% st_join(., centroids[centroids$Section == 1,], join = st_contains, left = FALSE) %&gt;% rename(geom_pol = geometry) %&gt;% mutate(Barcode_rn = Barcode) %&gt;% column_to_rownames(&quot;Barcode_rn&quot;) %&gt;% st_sf() ## Update the polygon object to keep the centroid geometries as well polygons &lt;- polygons %&gt;% left_join(as.data.frame(centroids)) %&gt;% rename(geom_cntd = geometry) %&gt;% st_sf(sf_column_name = &quot;geom_pol&quot;) ## Joining with `by = join_by(Barcode, pixel_x, pixel_y, Section)` ## Identify neighbours by Sphere Of Influence st_geometry(polygons) &lt;- &quot;geom_cntd&quot; nb_soi &lt;- graph2nb(soi.graph(nb_tri, polygons$geom_cntd), row.names = nb_names) nb_soi_w &lt;- nb2listwdist(nb_soi, polygons, type = &quot;idw&quot;, style = &quot;W&quot;, zero.policy = TRUE) ## Generate distance matrix dist.Mat &lt;- gw.dist(dp.locat = st_coordinates(polygons), p = 2) rownames(dist.Mat) &lt;- nb_names colnames(dist.Mat) &lt;- nb_names bw = (range(dist.Mat)[2])/2 kernel = &quot;bisquare&quot; w &lt;- gw.weight(vdist = dist.Mat, bw = bw, kernel = kernel, adaptive = FALSE) ## Plot on tissue polygons ggplot(data = polygons) + geom_sf(aes(geometry = geom_pol)) + theme_void() ## Plot neighbour graph ggplot() + geom_sf(data = polygons, aes(geometry = geom_pol), colour = &quot;grey30&quot;, fill = &quot;white&quot;) + geom_sf(data = as(nb2lines(nb_soi, coords = polygons$geom_cntd), &quot;sf&quot;), colour = &quot;black&quot;, linewidth = 0.25) + geom_sf(data = polygons, aes(geometry = geom_cntd), colour = &quot;black&quot;, size = 1) + theme_void() References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
