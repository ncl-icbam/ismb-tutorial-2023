--- 
title: "Spatial transcriptomics data analysis: theory and practice"
author: "Eleftherios Zormpas, Dr Simon J. Cockell"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
# url: your book url like https://bookdown.org/yihui/bookdown
# cover-image: path to the social sharing image like images/cover.jpg
description: "This book will guide you through the practical steps of the in-person tutorial IP2 for the ISMB/ECCB 2023 conference in Lyon named: Spatial transcriptomics data analysis: theory and practice."
link-citations: yes
github-repo: https://github.com/ncl-icbam/ismb-tutorial-2023.git
---

# url: your book url like https://bookdown.org/yihui/bookdown

Placeholder


## Abstract {-}
## Learning objectives {-}

<!--chapter:end:index.Rmd-->


# Practical session 1

Placeholder


## Log into the Posit Cloud server
## Import 10X Visium data
## Explore data types
### SpatialExperiment class
### Inspect the object
### Counts table and gene metadata
### Coordinates table and spot metadata
### Image metadata

<!--chapter:end:01-intro-to-stx.Rmd-->

# Practical session 2
In this session we will demonstrate the implementation of the methods discussed earlier and will particularly focus on the most common analysis routines in STx: QC, data visualisation and clustering analysis always inside the interoperable Bioconductor environment.

## Load packages {-}
```{r, message=FALSE}
library(ggspavis)
library(scater)
```

- [`ggspavis`](https://bioconductor.org/packages/release/bioc/html/ggspavis.html) is a Bioconductor package that includes visualization functions for spatially resolved transcriptomics datasets stored in `SpatialExperiment` format from spot-based (e.g., 10x Genomics Visium) platforms (@ggspavis2023Apr).

- [`scater`](https://bioconductor.org/packages/release/bioc/html/scater.html) is also a Bioconductor package that is a selection of tools for doing various analyses of scRNA-seq gene expression data, with a focus on quality control and visualization which has extended applications to STx data too. It is based on the `SingleCellExperiment` and `SpatialExperiment` classes and thus is interoperable with many other Bioconductor packages such as [`scran`](https://bioconductor.org/packages/3.16/scran), [`scuttle`](https://bioconductor.org/packages/3.16/scuttle) and [`iSEE`](https://bioconductor.org/packages/3.16/iSEE).


## Spot-level Quality Control
Spot-level quality control (sQC) procedures are employed to eliminate low-quality spots before conducting further analyses. Low-quality spots may result from issues during library preparation or other experimental procedures, such as a high percentage of dead cells due to cell damage during library preparation, or low mRNA capture efficiency caused by ineffective reverse transcription or PCR amplification. Keeping these spots usually leads to creating problems during downstream analyses.

We can identify low-quality spots using several characteristics that are also used in QC for scRNA-sq data, including:

1. **library size** (total of UMI counts per spot is going to be different due to sequencing *-like different samples in a bulk RNA-seq-* or due to number of cells in the spot)
2. **number of expressed genes** (i.e. number of genes with non-zero UMI counts per spot)
3. **proportion of reads mapping to mitochondrial genes** (a high proportion indicates putative cell damage)

Low library size or low number of expressed features can indicate poor mRNA capture rates, e.g. due to cell damage and missing mRNAs, or low reaction efficiency. A high proportion of mitochondrial reads indicates cell damage, e.g. partial cell lysis leading to leakage and missing cytoplasmic mRNAs, with the resulting reads therefore concentrated on the remaining mitochondrial mRNAs that are relatively protected inside the mitochondrial membrane. Unusually high numbers of cells per spot can indicate problems during cell segmentation.

The idea of using scRNA-seq QC metrics in STx data comes from the fact that if we remove space and count each spot as a single cell, the two datasets share common features. However, the expected distributions for high-quality spots are different (compared to high-quality cells in scRNA-seq), since spots may contain zero, one, or multiple cells.

A few publications for further reading that can help you understand the quality controls: @McCarthy2017Apr and @Amezquita2020Feb.

### Plot tissue map
The DLPFC dataset we will be using comes with manual annotations by the authors @Maynard2021Mar. We can plot the tissue map with and without the annotations to get a complete view.

```{r, fig.show = 'hold', out.width="50%", fig.height=5, fig.width=4}
## Plot spatial coordinates without annotations
plotSpots(spe)

## Plot spatial coordinates with annotations
plotSpots(spe,
          annotate = "ground_truth")
```

### Calculating QC metrics
We will now calculate the three main QC metrics described above using methods from the `scater` [@McCarthy2017Apr] package and our own functions **INSERT LINK OR CITATION HERE**.

So far, the dataset contains both on- and off-tissue spots. For the analysis though we are only interested in the on-tissue spots. Therefore, before we run any calculations we want to remove the off-tissue spots.

***NOTE***: the on- or off-tissue information for each spot can be found in the `colData` of the `spe` object and in the `in_tissue` column where *0 = off-tissue* and *1 = on-tissue*.

```{r}
## Dataset dimensions before the filtering
dim(spe)

## Subset to keep only on-tissue spots
spe <- spe[, colData(spe)$in_tissue == 1]
dim(spe)
```

The next thing we need to do before we make decisions on how to quality *"trim"* the dataset is to calculate the percentage per spot of mitochodrial gene expression and store this information inside the `colData`.

```{r}
## Fetch mitochondrial gene names
is_mito <- grepl("(^MT-)|(^mt-)", rowData(spe)$gene_name)
rowData(spe)$gene_name[is_mito]
```

```{r}
## Calculate per-spot QC metrics and store in colData
spe <- addPerCellQC(spe, subsets = list(mito = is_mito))
head(colData(spe))
```

After calculating the necessary metrics, we need to apply some cut-off thresholds for each metric to perform QC over each spot. What is important to remember here is that each dataset might need slightly different cut-off values to be applied. As a result we cannot rely on identifying a value to use every time and we need to rely on plotting these metrics and making a decision on a dataset-by-dataset basis.

### Library size threshold plot
Library size represents the total sum of UMI counts per spot. This is included in the column labeled `sum` in the `scater` output.

Plot a histogram of the library sizes across spots.

```{r, fig.height=3.5, warning=FALSE, message=FALSE}
## Density and histogram of library sizes
ggplot(data = as.data.frame(colData(spe)),
       aes(x = sum)) +
  geom_histogram(aes(y = after_stat(density)), 
                 colour = "black", 
                 fill = "grey") +
  geom_density(alpha = 0.5,
               adjust = 0.5,
               fill = "#A0CBE8",
               colour = "#4E79A7") +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 10)) + 
  scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) + 
  xlab("Library size") + 
  ylab("Density") + 
  theme_classic()
```

The distribution is relatively smooth, and there are no obvious issue such as a spike at very low library sizes.

We also plot the library sizes against the number of cells per spot (which is available for this dataset). This is to check that we are not inadvertently removing a biologically meaningful group of spots. The horizontal line (argument `threshold`) shows our first guess at a possible filtering threshold for library size based on the histogram.

```{r, fig.width=7, fig.height=5, warning=FALSE, message=FALSE}
# plot library size vs. number of cells per spot
plotQC(spe, type = "scatter", 
       metric_x = "cell_count", metric_y = "sum", 
       threshold_y = 600)
```

The plot shows that setting a filtering threshold for library size (e.g. at the value shown) does not appear to select for any obvious biologically consistent group of spots.

We set a relatively arbitrary threshold of 600 UMI counts per spot, and then check the number of spots below this threshold.

```{r}
# select QC threshold for library size
qc_lib_size <- colData(spe)$sum < 600
table(qc_lib_size)
colData(spe)$qc_lib_size <- qc_lib_size
```

Finally, we also check that the discarded spots do not have any obvious spatial pattern that correlates with known biological features. Otherwise, removing these spots could indicate that we have set the threshold too high, and are removing biologically informative spots.

```{r, fig.height=3.5}
# check spatial pattern of discarded spots
plotQC(spe, type = "spots", 
       discard = "qc_lib_size")
```

As an aside, here we can also illustrate what happens if we set the threshold too high. For example, if we set the threshold to 2000 UMI counts per spot -- which may also seem like a reasonable value based on the histogram and scatterplot -- then we see a possible spatial pattern in the discarded spots, matching the cortical layers. This illustrates the importance of interactively checking exploratory visualizations when choosing these thresholds.

```{r, fig.height=3.5}
# check spatial pattern of discarded spots if threshold is too high
qc_lib_size_2000 <- colData(spe)$sum < 2000
colData(spe)$qc_lib_size_2000 <- qc_lib_size_2000
plotQC(spe, type = "spots", 
       discard = "qc_lib_size_2000")
```

For reference, remember the ground truth layers in this dataset that we [plotted][Plot tissue map] at the beginning.









<!--chapter:end:02-stx-analysis.Rmd-->

# Practical session 2
This practical session will demonstrate the application of the most commonly used spatial analysis tools to STx data, and how we work with coordinate data alongside expression data. 

##

<!--chapter:end:03-intro-geospatial.Rmd-->

# Practical session 2
In this session we will have a hands-on exploration of GW-PCA and its application to STx data. What can we learn from this novel technique?

##

<!--chapter:end:04-gwpca.Rmd-->


# Blocks

Placeholder


## Equations
## Theorems and proofs
## Callout blocks

<!--chapter:end:05-blocks.Rmd-->


# Sharing your book

Placeholder


## Publishing
## 404 pages
## Metadata for sharing

<!--chapter:end:06-share.Rmd-->

`r if (knitr::is_html_output()) '
# References {-}
'`

<!--chapter:end:07-references.Rmd-->

